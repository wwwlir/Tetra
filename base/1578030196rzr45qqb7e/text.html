<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-size:xx-large; font-weight:600;">Используйте Stream API проще (или не используйте вообще) </span></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a href="https://habr.com/ru/hub/programming/"><span style=" text-decoration: underline; color:#0000ff;">Программирование</span></a>, </li>
<li style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a href="https://habr.com/ru/hub/java/"><span style=" text-decoration: underline; color:#0000ff;">Java</span></a> </li></ul>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="post-content-body"></a>С появлением Java 8 Stream API позволило программистам писать существенно короче то, что раньше занимало много строк кода. Однако оказалось, что многие даже с использованием Stream API пишут длиннее, чем надо. Причём это не только делает код длиннее и усложняет его понимание, но иногда приводит к существенному провалу производительности. Не всегда понятно, почему люди так пишут. Возможно, они прочитали только небольшой кусок документации, а про другие возможности не слышали. Или вообще документацию не читали, просто видели где-то пример и решили сделать похоже. Иногда это напоминает анекдот про «задача сведена к предыдущей».</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">В этой статье я собрал те примеры, с которыми столкнулся в практике. Надеюсь, после такого ликбеза код программистов станет чуточку красивее и быстрее. Большинство этих штук хорошая IDE поможет вам исправить, но IDE всё-таки не всесильна и голову не заменяет.<a name="habracut"></a><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1. Стрим из коллекции без промежуточных операций обычно не нужен</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если у вас промежуточных операций нет, часто можно и нужно обойтись без стрима.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1.1. collection.stream().forEach()</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Хотите что-то сделать для всех элементов коллекции? Замечательно. Но зачем вам стрим? Напишите просто <span style=" font-family:'monospace';">collection.forEach()</span>. В большинстве случаев это одно и то же, но короче и производит меньше мусора. Некоторые боятся, что различие в функциональности есть, но не могут толком объяснить, какое оно. Говорят, мол, <span style=" font-family:'monospace';">forEach</span> не гарантирует порядок. Как раз в стриме по спецификации не гарантирует (по факту он есть), а без стрима для упорядоченных коллекций гарантирует. Если порядок вам не нужен, вам не станет хуже, если он появится. Единственное отличие из стандартной библиотеки, которое мне известно — это синхронизированные коллекции, созданные через <span style=" font-family:'monospace';">Collections.synchronizedXyz()</span>. В этом случае <span style=" font-family:'monospace';">collection.forEach()</span> синхронизирует всю операцию, тогда как <span style=" font-family:'monospace';">collection.stream().forEach()</span> не синхронизирует ничего. Скорее всего, если вы уж используете синхронизированные коллекции, вам всё-таки синхронизация нужна, поэтому станет только лучше.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1.2. collection.stream().collect(Collectors.toList())</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Собираетесь преобразовать произвольную коллекцию в список? Замечательно. Начиная с Java 1.2 у вас есть отличная возможность для этого: <span style=" font-family:'monospace';">new ArrayList&lt;&gt;(collection)</span> (ну хорошо, до Java 5 дженериков не было). Это не только короче, но и быстрее и опять же создаст меньше мусора в куче. Может быть значительно меньше, так как в большинстве случаев у вас выделится один массив нужного размера, тогда как стрим будет добавлять элементы по одному, растягивая по мере необходимости. Аналогично вместо <span style=" font-family:'monospace';">stream().collect(toSet())</span> создаём <span style=" font-family:'monospace';">new HashSet&lt;&gt;()</span>, а вместо <span style=" font-family:'monospace';">stream().collect(toCollection(TreeSet::new))</span> — <span style=" font-family:'monospace';">new TreeSet&lt;&gt;()</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1.3. collection.stream().toArray(String[]::new)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Новый способ преобразования в массив ничем не лучше старого доброго <span style=" font-family:'monospace';">collection.toArray(new String[0])</span>. Опять же: так как на пути меньше абстракций, преобразование может оказаться более эффективно. Во всяком случае объект стрима вам не нужен.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1.4. collection.stream().max(Comparator.naturalOrder()).get()</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Есть замечательный метод <span style=" font-family:'monospace';">Collections.max</span>, который почему-то незаслуженно многими забыт. Вызов <span style=" font-family:'monospace';">Collections.max(collection)</span> сделает то же самое и опять же с меньшим количеством мусора. Если у вас свой компаратор, используйте <span style=" font-family:'monospace';">Collections.max(collection, comparator)</span>. Метод <span style=" font-family:'monospace';">Collections.max()</span> подойдёт хуже, если вы хотите специально обработать пустую коллекцию, тогда стрим более оправдан. Цепочка <span style=" font-family:'monospace';">collection.stream().max(comparator).orElse(null)</span> смотрится лучше, чем <span style=" font-family:'monospace';">collection.isEmpty() ? null : Collections.max(collection, comparator)</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">1.5. collection.stream().count()</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Это совсем ни в какие ворота не лезет: есть ведь <span style=" font-family:'monospace';">collection.size()</span>! Если в Java 9 <span style=" font-family:'monospace';">count()</span> отработает быстро, то в Java 8 этот вызов всегда пересчитывает все элементы, даже если размер очевиден. Не делайте так.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2. Поиск элемента</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2.1. stream.filter(condition).findFirst().isPresent()</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Такой код вижу на удивление часто. Суть его: проверить, выполняется ли условие для какого-то элемента стрима. Именно для этого есть специальный метод: <span style=" font-family:'monospace';">stream.anyMatch(condition)</span>. Зачем вам <span style=" font-family:'monospace';">Optional</span>?</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2.2. !stream.anyMatch(condition)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Тут некоторые поспорят, но я считаю, что использовать специальный метод <span style=" font-family:'monospace';">stream.noneMatch(condition)</span> более выразительно. А вот если и в условии отрицание: <span style=" font-family:'monospace';">!stream.anyMatch(x -&gt; !condition(x))</span>, то тут однозначно лучше написать <span style=" font-family:'monospace';">stream.allMatch(x -&gt; condition(x))</span>. Тот, кто будет читать код, скажет вам спасибо.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">2.3. stream.map(condition).anyMatch(b -&gt; b)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">И такой странный код иногда пишут, чтобы запутать коллег. Если увидите такое, знайте, что это просто <span style=" font-family:'monospace';">stream.anyMatch(condition)</span>. Здесь же вариации на тему вроде <span style=" font-family:'monospace';">stream.map(condition).noneMatch(Boolean::booleanValue)</span> или <span style=" font-family:'monospace';">stream.map(condition).allMatch(Boolean.TRUE::equals)</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3. Создание стрима</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3.1. Collections.emptyList().stream()</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Нужен пустой стрим? Бывает, ничего страшного. И для этого есть специальный метод <span style=" font-family:'monospace';">Stream.empty()</span>. Производительность одинаковая, но короче и понятнее. Метод <span style=" font-family:'monospace';">emptySet</span> здесь не отличается от <span style=" font-family:'monospace';">emptyList</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3.2. Collections.singleton(x).stream()</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">И тут можно упростить жизнь: если вам потребовался стрим из одного элемента, пишите просто <span style=" font-family:'monospace';">Stream.of(x)</span>. Опять же без разницы <span style=" font-family:'monospace';">singleton</span> или <span style=" font-family:'monospace';">singletonList</span>: когда в стриме один элемент, никого не волнует, упорядочен стрим или нет.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3.3. Arrays.asList(array).stream()</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Развитие этой же темы. Люди почему-то так делают, хотя <span style=" font-family:'monospace';">Arrays.stream(array)</span> или <span style=" font-family:'monospace';">Stream.of(array)</span> отработает не хуже. Если вы указываете элементы явно (<span style=" font-family:'monospace';">Arrays.asList(x, y, z).stream()</span>), то <span style=" font-family:'monospace';">Stream.of(x, y, z)</span> тоже сработает. Аналогично с <span style=" font-family:'monospace';">EnumSet.of(x, y, z).stream()</span>. Вам же стрим нужен, а не коллекция, так и создавайте сразу стрим.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3.4. Collections.nCopies(N, &quot;ignored&quot;).stream().map(ignored -&gt; new MyObject())</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Нужен стрим из N одинаковых объектов? Тогда <span style=" font-family:'monospace';">nCopies()</span> — ваш выбор. А вот если нужно сгенерировать стрим из N объектов, созданных одним и тем же способом, то тут красивее и оптимальнее воспользоваться <span style=" font-family:'monospace';">Stream.generate(() -&gt; new MyObject()).limit(N)</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">3.5. IntStream.range(from, to).mapToObj(idx -&gt; array[idx])</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Нужен стрим из куска массива? Есть специальный метод <span style=" font-family:'monospace';">Arrays.stream(array, from, to)</span>. Опять же короче и меньше мусора, плюс так как массив больше не захвачен лямбдой, он не обязан быть effectively-final. Понятно, если from — это 0, а to — это <span style=" font-family:'monospace';">array.length</span>, тогда вам просто нужен <span style=" font-family:'monospace';">Arrays.stream(array)</span>, причём тут код станет приятнее, даже если в <span style=" font-family:'monospace';">mapToObj</span> что-то более сложное. Например, <span style=" font-family:'monospace';">IntStream.range(0, strings.length).mapToObj(idx -&gt; strings[idx].trim())</span> легко превращается в <span style=" font-family:'monospace';">Arrays.stream(strings).map(String::trim)</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Более хитрая вариация на тему — <span style=" font-family:'monospace';">IntStream.range(0, Math.min(array.length, max)).mapToObj(idx -&gt; array[idx])</span>. Немножко подумав, понимаешь, что это <span style=" font-family:'monospace';">Arrays.stream(array).limit(max)</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">4. Ненужные и сложные коллекторы</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Иногда люди изучают коллекторы и всё пытаются делать через них. Однако не всегда они нужны.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">4.1. stream.collect(Collectors.counting())</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Многие коллекторы нужны только как вторичные в сложных каскадных операциях вроде <span style=" font-family:'monospace';">groupingBy</span>. Коллектор <span style=" font-family:'monospace';">counting()</span> как раз из них. Пишите <span style=" font-family:'monospace';">stream.count()</span> и не мучайтесь. Опять же если в Java 9 <span style=" font-family:'monospace';">count()</span> может иногда выполниться за константное время, то коллектор всегда будет пересчитывать элементы. А в Java 8 коллектор <span style=" font-family:'monospace';">counting()</span> ещё и боксит зазря (я это исправил в Java 9). Из этой же оперы коллекторы <span style=" font-family:'monospace';">maxBy()</span>, <span style=" font-family:'monospace';">minBy()</span> (есть методы <span style=" font-family:'monospace';">max()</span> и <span style=" font-family:'monospace';">min()</span>), <span style=" font-family:'monospace';">reducing()</span> (используйте <span style=" font-family:'monospace';">reduce()</span>), <span style=" font-family:'monospace';">mapping()</span> (просто добавьте шаг <span style=" font-family:'monospace';">map()</span>, а затем воспользуйтесь вторичным коллектором напрямую). В Java 9 добавились <span style=" font-family:'monospace';">filtering()</span> и <span style=" font-family:'monospace';">flatMapping()</span>, которые также дублируют соответствующие промежуточные операции.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">4.2. groupingBy(classifier, collectingAndThen(maxBy(comparator), Optional::get))</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Частая задача: хочется сгруппировать элементы по классификатору, выбрав в каждой группе максимум. В SQL это выглядит просто <span style=" font-family:'monospace';">SELECT classifier, MAX(...) FROM ... GROUP BY classifier</span>. Видимо, пытаясь перенести опыт SQL, люди пытаются использовать тот же самый groupingBy и в Stream API. Казалось бы должно сработать <span style=" font-family:'monospace';">groupingBy(classifier, maxBy(comparator))</span>, но нет. Коллектор <span style=" font-family:'monospace';">maxBy</span> возвращает <span style=" font-family:'monospace';">Optional</span>. Но мы-то знаем, что вложенный <span style=" font-family:'monospace';">Optional</span> всегда не пуст, так как в каждой группе по крайней мере один элемент есть. Поэтому приходится добавлять некрасивые шаги вроде <span style=" font-family:'monospace';">collectingAndThen</span>, и всё начинает выглядеть совсем чудовищно.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Однако отступив на шаг назад, можно понять, что <span style=" font-family:'monospace';">groupingBy</span> тут не нужен. Есть другой замечательный коллектор — <span style=" font-family:'monospace';">toMap</span>, и это как раз то что надо. Мы просто хотим собрать элементы в <span style=" font-family:'monospace';">Map</span>, где ключом будет классификатор, а значением сам элемент. В случае же дубликата выберем больший из них. Для этого, кстати, есть <span style=" font-family:'monospace';">BinaryOperator.maxBy(comparator)</span>, который можно статически импортировать вместо одноимённого коллектора. В результате имеем: <span style=" font-family:'monospace';">toMap(classifier, identity(), maxBy(comparator))</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Если вы порываетесь использовать <span style=" font-family:'monospace';">groupingBy</span>, а вторичным коллектором у вас <span style=" font-family:'monospace';">maxBy</span>, <span style=" font-family:'monospace';">minBy</span> или <span style=" font-family:'monospace';">reducing</span> (возможно, с промежуточным <span style=" font-family:'monospace';">mapping</span>), посмотрите в сторону коллектора <span style=" font-family:'monospace';">toMap</span> — может полегчать.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">5. Не считайте то, что не нужно считать</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">5.1. listOfLists.stream().flatMap(List::stream).count()</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Это перекликается с пунктом 1.5. Мы хотим посчитать суммарное число элементов во вложенных коллекциях. Казалось бы всё логично: растянем эти коллекции в один стрим с помощью <span style=" font-family:'monospace';">flatMap</span> и пересчитаем. Однако в большинстве случаев размеры вложенных списков уже посчитаны, хранятся у них в поле и легко доступны с помощью метода <span style=" font-family:'monospace';">size()</span>. Небольшая модификация существенно увеличит скорость операции: <span style=" font-family:'monospace';">listOfLists.stream().mapToInt(List::size).sum()</span>. Если боитесь, что <span style=" font-family:'monospace';">int</span> переполнится, <span style=" font-family:'monospace';">mapToLong</span> тоже сработает.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">5.2. if(stream.filter(condition).count() &gt; 0)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Опять же забавный способ записать <span style=" font-family:'monospace';">stream.anyMatch(condition)</span>. Но в отличие от довольно безобидного 2.1 вы тут теряете короткое замыкание: будут перебраны все элементы, даже если условие сработало на самом первом. Аналогично если вы проверяете <span style=" font-family:'monospace';">filter(condition).count() == 0</span>, лучше воспользоваться <span style=" font-family:'monospace';">noneMatch(condition)</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">5.3. if(stream.count() &gt; 2)</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Этот случай более хитрый. Вам теперь важно знать, больше двух элементов в стриме или нет. Если вас волнует производительность, возможно, стоит вставить <span style=" font-family:'monospace';">stream.limit(3).count()</span>. Вам ведь не важно, сколько их, если их больше двух.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">6. Разное</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">6.1. stream.sorted(comparator).findFirst()</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Что хотел сказать автор? Отсортируй стрим и возьми первый элемент. Это же всё равно что взять минимальный элемент: <span style=" font-family:'monospace';">stream.min(comparator)</span>. Иногда видишь даже <span style=" font-family:'monospace';">stream.sorted(comparator.reversed()).findFirst()</span>, что аналогично <span style=" font-family:'monospace';">stream.max(comparator)</span>. Реализация Stream API не соптимизирует тут (хотя могла бы), а сделает всё как вы сказали: соберёт стрим в промежуточный массив, отсортирует его весь и выдаст вам первый элемент. Вы существенно потеряете в памяти и скорости на такой операции. Ну и, конечно, замена существенно понятнее.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">6.2. stream.map(x -&gt; {counter.addAndGet(x);return x;})</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">Некоторые люди пытаются выполнить какой-нибудь побочный эффект в стриме. Вообще это в принципе уже звоночек, что может стрим вам вовсе и не нужен. Но так или иначе для этих целей есть специальный метод <span style=" font-family:'monospace';">peek</span>. Пишем <span style=" font-family:'monospace';">stream.peek(counter::addAndGet)</span>.</p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<hr />
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">На этом у меня всё. Если вы сталкивались со странными и неэффективными способами использования Stream API, напишите о них в комментариях.</p>
<p style="-qt-paragraph-type:empty; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style="-qt-paragraph-type:empty; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" color:#000000;">//////////////////////////////////////////////////////</span></p>
<p style="-qt-paragraph-type:empty; margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; color:#000000;"><br /></p></body></html>